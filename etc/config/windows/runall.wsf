<?xml version="1.0" ?>
<package>
    <comment>
        Licensed to the Apache Software Foundation (ASF) under one
        or more contributor license agreements.  See the NOTICE file
        distributed with this work for additional information
        regarding copyright ownership.  The ASF licenses this file
        to you under the Apache License, Version 2.0 (the
        "License"); you may not use this file except in compliance
        with the License.  You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing,
        software distributed under the License is distributed on an
        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, either express or implied.  See the License for the
        specific language governing permissions and limitations
        under the License.
    </comment>
    <job id="runexamples" prompt="no">
        <?job error="false" debug="false" ?>
        <runtime>
            <description>
runs examples and checks results.
            </description>
            <named helpstring="The root directory with executables" 
                name="EXEDIR" required="true" type="string"/>
            <named helpstring="The root directory with .in and .out files" 
                name="INOUTDIR" required="false" type="string"/>
            <named helpstring="The build type" name="BUILDTYPE" 
                required="true" type="string"/>
            <named helpstring="The configuration" name="CONFIG" 
                required="true" type="string"/>
            <named helpstring="The log file" name="LOGFILE" 
                required="false" type="string"/>
            <named helpstring="The copy stdlibxx.dll to exe option" name="COPYDLL" 
                required="false" type="string"/>
            <named helpstring="The lib dll folder" name="LIBDIR" 
                required="false" type="string"/>
            <named helpstring="The examples extension" name="EXT" 
                required="false" type="string"/>
            <example>
            cscript runexamples.wsf /EXEDIR:"C:\stdcxx\build" 
            /INOUTDIR:"C:\stdcxx\build" /BUILDTYPE:11d /CONFIG:msvc-7.1
            </example>
            <usage>
Usage: cscript runexamples.wsf /EXEDIR:@EXEDIR [/INOUTDIR:@INOUTDIR] 
/BUILDTYPE:@BUILDTYPE /CONFIG:@CONFIG [/LOGFILE:@LOGFILE]
[/COPYDLL:@COPYDLL] [/LIBDIR:@LIBDIR] [/EXT:@EXT]
where
@EXEDIR is the root directory with executables ro be run and checked,
@TOPDIR is the root directory with .in and .out files 
required by executables,
@BUILDTYPE is the build type (11d, 11s, etc).
@CONFIG is the compiler configuration (msvc-7.1, icc-9.0, etc).
@LOGFILE is the log file name.
@COPYDLL is the option for copy stdlibxx.dll to executables
@LIBDIR is the library dll folder (specify when COPYDLL is true)
@EXT is the extension of the example files, default value: "exe"
            </usage>
        </runtime>
        <object id="fso" progid="Scripting.FileSystemObject"/>
        <object id="WshShell" progid="WScript.Shell"/>
        <script language="JScript" src="config.js"/>
        <script language="JScript" src="utilities.js"/>
        <script language="JScript" src="summary.js"/>
        <script id="runexamples" language="JScript">
<![CDATA[
//
// Examples running script for stdcxx library
//

var examplesDir = ""; // path to the root directory containing executables
var inoutDir = "";    // path to the root directory 
    // containing the .in and .out files
var buildType = ""      // the buid type (11d, 11s, etc)
var currentCfg = "msvc-7.1" // the configuration
var logFileName = ""; // the log file name
var logFileDefault = "runexamples.log"; // the default log file name
var copyDll = false;
var libdllFolder = "";
var ext = "exe";

var varOut = "out";

var exRun = 0;
var exRunSucceeded = 0;
var exRunFailed = 0;
var exRunTimedOut = 0;
var exBadCode = 0;

var runTimeout = 180;

var buildlogFile = "BuildLog.htm";
var summaryFileName = "Summary.htm";
var htmFolderName = "temphtm";
var libFileName = "stdlib";

var utlExec = "exec.exe";
var unicodeLog = false;
    
var description = new runexamples; // run

// the main function of the script
function runexamples()
{
    readAndCheckArguments();
    
    getCompilerOpts(currentCfg);

    unicodeLog = UNICODELOG;

    var buildOutDir = examplesDir;
    if (! fso.FolderExists(buildOutDir))
        fso.CreateFolder(buildOutDir);
        
    var fLog = fso.CreateTextFile(examplesDir + "\\" + logFileName);
    var fSummary = fso.CreateTextFile(buildOutDir + "\\" + summaryFileName);
    
    runAllExamples(examplesDir, inoutDir, fLog, fSummary, ext);
    
    WScript.Echo("Total run " + exRun + "; " + exRunSucceeded 
        + " succeeded, " 
        +  exRunFailed + " failed, " + exRunTimedOut 
        + " failed because of timeout, " + exBadCode 
        + " exited with non-zero code");
        
    fLog.WriteLine("Total run " + exRun + "; " + exRunSucceeded 
        + " succeeded, " 
        +  exRunFailed + " failed, " + exRunTimedOut 
        + " failed because of timeout, " + exBadCode
        + " exited with non-zero code");
        
    fLog.Close();
    fSummary.Close();
    
    WScript.Quit(0);
}

// performs checking of the script parameters
function readAndCheckArguments()
{
    if (!WScript.Arguments.Named.Exists("EXEDIR"))
    {
        WScript.StdErr.WriteLine(
            "Generate: Missing required argument EXEDIR.");
        WScript.Arguments.ShowUsage();
        WScript.Quit(2);
    }
    
    if (!WScript.Arguments.Named.Exists("BUILDTYPE"))
    {
        WScript.StdErr.WriteLine(
            "Generate: Missing required argument BUILDTYPE.");
        WScript.Arguments.ShowUsage();
        WScript.Quit(2);
    }
    
    examplesDir =  WScript.Arguments.Named("EXEDIR");
    buildType = WScript.Arguments.Named("BUILDTYPE");

    if (WScript.Arguments.Named.Exists("INOUTDIR"))
        inoutDir =  WScript.Arguments.Named("INOUTDIR");

    utlExec = examplesDir + "\\..\\bin\\" + utlExec;
    
    if (WScript.Arguments.Named.Exists("CONFIG"))
        currentCfg = WScript.Arguments.Named("CONFIG");
    
    if (WScript.Arguments.Named.Exists("LOGFILE"))
        logFileName = WScript.Arguments.Named("LOGFILE");
    else
        logFileName = logFileDefault;
        
    if (WScript.Arguments.Named.Exists("COPYDLL"))
    {
        var copyOption = WScript.Arguments.Named("COPYDLL");
        if ("true" == copyOption)
            copyDll = true;
    }
    
    if (WScript.Arguments.Named.Exists("LIBDIR"))
        libdllFolder = WScript.Arguments.Named("LIBDIR");
    
    if (WScript.Arguments.Named.Exists("EXT"))
        ext = WScript.Arguments.Named("EXT");
    
    if (! fso.FolderExists(examplesDir))
    {
        WScript.StdErr.WriteLine(
            "Generate: Could not find directory " + examplesDir);
            
        WScript.Quit(3);
    }
    
    if (0 < inoutDir.length && !fso.FolderExists(inoutDir))
    {
        WScript.StdErr.WriteLine(
            "Generate: Could not find directory " + inoutDir);
            
        WScript.Quit(3);
    }
}

// run all executables starting from exeDir
// exeDir - starting folder to search executables in
// srcDir - starting folder to search .in and .out files for the executable
// fileLog - filename of the logfile
// fileSimmary - filename of the summary file
function runAllExamples(exeDir, srcDir, fileLog, fileSummary, exeExt)
{
    var exeFolder = fso.GetFolder(exeDir);
    if (! exeFolder)
        return;
    
    var htmDir = exeDir + "\\" + htmFolderName;
    if (! fso.FolderExists(htmDir))
        fso.CreateFolder(htmDir);

    var exeFiles = new Array();
    var arrInfo = new Array();
    
    var rx = new RegExp("^.+\\.(?:" + exeExt + ")$", "i");
    var enumExeFiles = new Enumerator(exeFolder.Files);
    for (; !enumExeFiles.atEnd(); enumExeFiles.moveNext())
    {
        var exeFileName = enumExeFiles.item().Name;
        if (! rx.test(exeFileName))
            continue;
            
        var itemInfo = 
            new ItemBuildInfo(getPureFileName(exeFileName, exeExt));
        readBuildLog(exeDir, itemInfo, unicodeLog);

        itemInfo.runReqOutput = readOutFile(srcDir, exeFileName, exeExt);

        exeFiles.push(exeFileName);
        arrInfo.push(itemInfo);
        
        ++exRun;
    }
    
    // temporary copy the dll to the executable
    if (copyDll)
    {
        var dllName = libFileName + buildType + ".dll";
        var copyDllCmd = "cmd /c \"copy /Y " + libdllFolder + "\\" + dllName +
                         " " + exeDir + "\\" + dllName + "\"";
                            
        WshShell.Run(copyDllCmd, 7, true);
    }

    var runCmd = "\"" + utlExec + "\" -t " + runTimeout;
    
    if (0 < srcDir.length)
        runCmd += " -d \"" + srcDir + "\"";
        
    runCmd += " " + exeFiles.join(" ");
    
    var prevDir = WshShell.CurrentDirectory;
    WshShell.CurrentDirectory = exeDir;
    var oExec = WshShell.Exec(runCmd);
    WshShell.CurrentDirectory = prevDir;
    
    if (!oExec)
    {
        // WScript.Echo(itemInfo.name + " failed to run");
        return;
    }

    var execOut = "";
    while (oExec.Status == 0)
    {
        execOut += oExec.StdOut.ReadAll();
        WScript.Sleep(500);
    }
    
    WScript.Echo(execOut);
    
    // delete the dll if it was copied
    if (copyDll)
    {
        try
        {
            fso.DeleteFile(exeFolder.Path + "\\" + dllName);
        }
        catch(e)
        {
            fileLog.WriteLine("error: could not delete temporary file" + 
                exeFolder.Path + "\\" + dllName);
        }
    }

    for (var i = 0; i < arrInfo.length; ++i)
    {
        var itemInfo = arrInfo[i];
        
        var outFileName = exeDir + "\\" + itemInfo.name + ".out";

        try
        {   
            var outFile = fso.OpenTextFile(outFileName, 1);
            if (!outFile.AtEndOfStream)
                itemInfo.runOutput = outFile.ReadAll();
                
            outFile.Close();
            fso.DeleteFile(outFileName);
        }
        catch(e)
        {
            WScript.Echo("Could not delete temporary file " + outFileName);
        }
        
        itemInfo.exitCode = parseStatus(itemInfo.name + "." + exeExt, execOut);
        switch (itemInfo.exitCode)
        {
        case 0:  // OK
            ++exRunSucceeded;
            fileLog.WriteLine(itemInfo.name + " completed successfully, exit code " +
                itemInfo.exitCode);
            break;
        case -1: // KILLED
            ++exRunTimedOut;
            fileLog.WriteLine(itemInfo.name + " timed out");
            break;
        case -2: // DIFF
            fileLog.WriteLine(itemInfo.name + " completed successfully, " +
                "but output differs from the expected");
            getDifferencesInfo(itemInfo);
            ++exRunFailed;
            break;
        case -3: // SEGV
        case -4: // other
            ++exRunFailed;
            fileLog.WriteLine(itemInfo.name + " failed");
            break;
        default:
            ++exBadCode;
            fileLog.WriteLine(itemInfo.name + " completed successfully, exit code " +
                itemInfo.exitCode);
        }

        saveBuildInfo(itemInfo, htmDir, "htm"); 
        saveBuildSummary(itemInfo, fileSummary);
    }
}

// parse the exec utility output to get status of the running executable 
// exename - filename of the executable
// exeOut - stdout content of the exec utility
function parseStatus(exeName, execOut)
{
    var res = 0;

    // maxNameLen is the length of the "NAME" column in the exec utility output
    var maxNameLen = 25;
    var pos = execOut.indexOf(exeName.substr(0, maxNameLen));
    if (0 <= pos)
    {
        pos += maxNameLen + 1;
        var status = execOut.substring(pos, execOut.indexOf(" ", pos + 6));
        res = parseInt(status);
        if (isNaN(res))
        {
            switch (status)
            {
            case "KILLED":
                res = -1;
                break;
            case "  DIFF":
                res = -2;
                break;
            case "  SEGV":
                res = -3;
                break;
            default:
                res = -4;
            }
        }
    }

    return res;
}

// returns the content of the .in or .out file for the specified executable
// srcDir - folder containing subfolders with .in and .out files
// exeFileName - filename of the executable
// nameSuffix - one of varIn, varOut
function readAllFromFile(srcDir, exeFileName, nameSuffix, exeExt)
{   
    if (! fso.FolderExists(srcDir))
        return "";
        
    var pureName = getPureFileName(exeFileName, exeExt);
        
    var someDir = srcDir + "\\" + nameSuffix;
    if (! fso.FolderExists(someDir))
        return "";
        
    var someFileName = someDir + "\\" + pureName + "." + nameSuffix;
    if (! fso.FileExists(someFileName))
        return "";
        
    var someFile = fso.OpenTextFile(someFileName);
    if (! someFile)
        return "";
        
    return (someFile.ReadAll());
}

// returns the content of the .out file for the specified executable
// srcDir - folder containing .out files
// exeFileName - filename of the executable
function readOutFile(srcDir, exeFileName, exeExt)
{
    var outData = readAllFromFile(srcDir, exeFileName, varOut, exeExt);
    
    if (0 == outData.length)
    {
        outData = readAllFromFile(srcDir + "\\manual", exeFileName, varOut, exeExt);
        if (0 < outData.length)
            srcDir += "\\manual";
        else
        {
            outData = readAllFromFile(srcDir + "\\tutorial", exeFileName, varOut, exeExt);
            if (0 < outData.length)
                srcDir += "\\tutorial";
        }
    }
    
    var eolStr = String.fromCharCode(13) + String.fromCharCode(10);
    var idxEOL = outData.indexOf(eolStr);
    var outBegin = (idxEOL != -1) ? outData.substr(0, idxEOL) : outData;
    var rgWords = outBegin.split(" ");
    if (rgWords[0] != "link")
        return outData;
    
    // try to open file using the link
    var linkedFileName = srcDir + "\\" + varOut + "\\" + rgWords[1];
    if (! fso.FileExists(linkedFileName))
        return outData;
            
    var linkedFile = fso.OpenTextFile(linkedFileName);
    if (! linkedFile)
        return "";
            
    return (linkedFile.ReadAll());
}

// returns the filename without extension
// fileName - source filename
// fileExtension - extension of the file
function getPureFileName(fileName, fileExtension)
{   
    var pureName = fileName;
    var indexTmp = fileName.lastIndexOf("." + fileExtension);
    if (indexTmp != -1)
        pureName = fileName.substr(0, indexTmp);
        
    return pureName;
}


]]>
        </script>
    </job>
</package>
