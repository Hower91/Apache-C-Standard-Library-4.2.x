<?xml version="1.0" ?>
<package>
    <comment>
        Licensed to the Apache Software Foundation (ASF) under one
        or more contributor license agreements.  See the NOTICE file
        distributed with this work for additional information
        regarding copyright ownership.  The ASF licenses this file
        to you under the Apache License, Version 2.0 (the
        "License"); you may not use this file except in compliance
        with the License.  You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing,
        software distributed under the License is distributed on an
        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, either express or implied.  See the License for the
        specific language governing permissions and limitations
        under the License.
    </comment>
    <job id="runexamples" prompt="no">
        <?job error="false" debug="false" ?>
        <runtime>
            <description>
runs examples and checks results.
            </description>
            <named helpstring="The root directory with executables" 
                name="EXEDIR" required="true" type="string"/>
            <named helpstring="The root directory with .in and .out files" 
                name="INOUTDIR" required="true" type="string"/>
            <named helpstring="The build type" name="BUILDTYPE" 
                required="true" type="string"/>
            <named helpstring="The configuration" name="CONFIG" 
                required="true" type="string"/>
            <named helpstring="The log file" name="LOGFILE" 
                required="false" type="string"/>
            <named helpstring="The copy lib dll to exe option" name="COPYDLL" 
                required="false" type="string"/>
            <named helpstring="The copy lib dll to exe option" name="COPYRWTESTDLL" 
                required="false" type="string"/>
            <named helpstring="The lib dll folder" name="LIBDIR" 
                required="false" type="string"/>
            <example>
            cscript runexamples.wsf /EXEDIR:"C:\stdcxx\build" 
            /INOUTDIR:"C:\stdcxx\build" /BUILDTYPE:11d /CONFIG:msvc-7.1
            </example>
            <usage>
Usage: cscript runexamples.wsf /EXEDIR:@EXEDIR /INOUTDIR:@INOUTDIR 
/BUILDTYPE:@BUILDTYPE /CONFIG:@CONFIG
[/LOGFILE:@LOGFILE] [/COPYDLL:@COPYDLL] [/LIBDIR:@LIBDIR]
[/COPYRWTESTDLL:@COPYRWTESTDLL]
where
@EXEDIR is the root directory with executables ro be run and checked,
@TOPDIR is the root directory with .in and .out files 
required by executables,
@BUILDTYPE is the build type (11d, 11s, etc).
@CONFIG is the compiler configuration (msvc-7.1, icc-9.0, etc).
@LOGFILE is the log file name.
@COPYDLL is the option for copy dll to executables
@LIBDIR is the library dll folder (specify when COPYDLL is true)
@COPYRWTESTDLL is the option for copy rwtest.dll to executables
            </usage>
        </runtime>
        <object id="fso" progid="Scripting.FileSystemObject"/>
        <object id="WshShell" progid="WScript.Shell"/>
        <script language="JScript" src="config.js"/>
        <script language="JScript" src="utilities.js"/>
        <script language="JScript" src="summary.js"/>
        <script id="exrunner" language="JScript">
<![CDATA[
//
// Examples running script for stdcxx library
//

var examplesDir = ""; // path to the root directory containing executables
var inoutDir = "";    // path to the root directory 
    // containing the .in and .out files
var buildType = ""      // the buid type (11d, 11s, etc)
var currentCfg = "msvc-7.1" // the configuration
var logFileName = ""; // the log file name
var logFileDefault = "runexamples.log"; // the default log file name
var copyDll = false;
var copyRwtestDll = false;
var libdllFolder = "";

var varIn = "in";
var varOut = "out";

var exRun = 0;
var exRunSucceeded = 0;
var exRunFailed = 0;
var exRunTimedOut = 0;
var exBadCode = 0;

var runTimeout = 180;

var buildlogFile = "BuildLog.htm";
var summaryFileName = "Summary.htm";
var htmFolderName = "temphtm";
var libFileName = "stdlib";

var utlExec = "exec.exe";
var unicodeLog = false;
    
var description = new runexamples; // run

// the main function of the script
function runexamples()
{
    readAndCheckArguments();
    
    getCompilerOpts(currentCfg);

    unicodeLog = UNICODELOG;

    var buildOutDir = examplesDir;
    if (! fso.FolderExists(buildOutDir))
        fso.CreateFolder(buildOutDir);
        
    var fLog = fso.CreateTextFile(examplesDir + "\\" + logFileName);
    var fSummary = fso.CreateTextFile(buildOutDir + "\\" + summaryFileName);
    
    runAllExamples(examplesDir, inoutDir, fLog, fSummary);
    
    WScript.Echo("Total run " + exRun + "; " + exRunSucceeded 
        + " succeeded, " 
        +  exRunFailed + " failed, " + exRunTimedOut 
        + " failed because of timeout, " + exBadCode 
        + " exited with non-zero code");
        
    fLog.WriteLine("Total run " + exRun + "; " + exRunSucceeded 
        + " succeeded, " 
        +  exRunFailed + " failed, " + exRunTimedOut 
        + " failed because of timeout, " + exBadCode
        + " exited with non-zero code");
        
    fLog.Close();
    fSummary.Close();
    
    WScript.Quit(0);
}

// performs checking of the script parameters
function readAndCheckArguments()
{
    if (!WScript.Arguments.Named.Exists("EXEDIR"))
    {
        WScript.StdErr.WriteLine(
            "Generate: Missing required argument EXEDIR.");
        WScript.Arguments.ShowUsage();
        WScript.Quit(2);
    }
    
    if (!WScript.Arguments.Named.Exists("INOUTDIR"))
    {
        WScript.StdErr.WriteLine(
            "Generate: Missing required argument INOUTDIR.");
        WScript.Arguments.ShowUsage();
        WScript.Quit(2);
    }
    
    if (!WScript.Arguments.Named.Exists("BUILDTYPE"))
    {
        WScript.StdErr.WriteLine(
            "Generate: Missing required argument BUILDTYPE.");
        WScript.Arguments.ShowUsage();
        WScript.Quit(2);
    }
    
    examplesDir =  WScript.Arguments.Named("EXEDIR");
    inoutDir =  WScript.Arguments.Named("INOUTDIR");
    buildType = WScript.Arguments.Named("BUILDTYPE");

    utlExec = examplesDir + "\\..\\bin\\" + utlExec;
    
    if (WScript.Arguments.Named.Exists("CONFIG"))
        currentCfg = WScript.Arguments.Named("CONFIG");
    
    if (WScript.Arguments.Named.Exists("LOGFILE"))
        logFileName = WScript.Arguments.Named("LOGFILE");
    else
        logFileName = logFileDefault;
        
    if (WScript.Arguments.Named.Exists("COPYDLL"))
    {
        var copyOption = WScript.Arguments.Named("COPYDLL");
        if ("true" == copyOption)
            copyDll = true;
    }
    
    if (WScript.Arguments.Named.Exists("COPYRWTESTDLL"))
    {
        var copyOption = WScript.Arguments.Named("COPYRWTESTDLL");
        if ("true" == copyOption)
            copyRwtestDll = true;
    }
    
    if (WScript.Arguments.Named.Exists("LIBDIR"))
        libdllFolder = WScript.Arguments.Named("LIBDIR");
    
    if (! fso.FolderExists(examplesDir))
    {
        WScript.StdErr.WriteLine(
            "Generate: Could not find directory " + examplesDir);
            
        WScript.Quit(3);
    }
    
    if (! fso.FolderExists(inoutDir))
    {
        WScript.StdErr.WriteLine(
            "Generate: Could not find directory " + inoutDir);
            
        WScript.Quit(3);
    }
}

// run all executables starting from exeDir
// exeDir - starting folder to search executables in
// srcDir - starting folder to search .in and .out files for the executable
// fileLog - filename of the logfile
// fileSimmary - filename of the summary file
function runAllExamples(exeDir, srcDir, fileLog, fileSummary)
{
    var exeFolder = fso.GetFolder(exeDir);
    if (! exeFolder)
        return;
        
    var enumExeSubFolders = new Enumerator(exeFolder.SubFolders);
    for (; !enumExeSubFolders.atEnd(); enumExeSubFolders.moveNext())
    {
        var exeFolderName = enumExeSubFolders.item().Name;
        
        var newSrc = srcDir + "\\" + exeFolderName;
            
        runAllExamples(exeDir + "\\" + exeFolderName, 
            newSrc, fileLog, fileSummary);
    }
    
    var dllCopied = false;
    var rwtdllCopied = false;
    var rx = new RegExp("^.+\\.(?:exe)$", "i");
    var enumExeFiles = new Enumerator(exeFolder.Files);
    for (; !enumExeFiles.atEnd(); enumExeFiles.moveNext())
    {
        var exeFileName = enumExeFiles.item().Name;
        if (! rx.test(exeFileName))
            continue;
            
        // temporary copy the dll to the executable
        if (copyDll && !dllCopied)
        {
            var dllName = libFileName + buildType + ".dll";
            var copyDllCmd = "cmd /c \"copy /Y " + libdllFolder + "\\" + dllName +
                             " " + exeDir + "\\" + dllName + "\"";
                             
            WshShell.Run(copyDllCmd, 7, true);
            dllCopied = true;
        }
         
        // temporary copy the rwtest.dll to the executable
        if (copyRwtestDll && !rwtdllCopied)
        {
            var rwtdllName = "rwtest.dll";
            var copyDllCmd = "cmd /c \"copy /Y " + examplesDir + "\\" + rwtdllName +
                             " " + exeDir + "\\" + rwtdllName + "\"";
                             
            WshShell.Run(copyDllCmd, 7, true);
            rwtdllCopied = true;
        }
         
        var htmDir = exeDir + "\\" + htmFolderName;
        if (! fso.FolderExists(htmDir))
            fso.CreateFolder(htmDir);
            
        var itemInfo = 
            new ItemBuildInfo(getPureFileName(exeFileName, "exe"));
            
        var inData = readInFile(srcDir, exeFileName);
                
        var outData = readOutFile(srcDir, exeFileName);
            
        // run example
        var runCmd = exeDir + "\\" + exeFileName;
        WScript.Echo("running " + exeFileName);
        fileLog.WriteLine("running " + exeFileName);

        exRun++;
        
        if (inData != "" || outData != "")
            runWithChecks(runCmd, exeFileName, itemInfo, outData, fileLog);
        else
            runNoChecks(runCmd, exeFileName, itemInfo, fileLog); 
            
        readBuildLog(exeDir, itemInfo, unicodeLog);
        saveBuildInfo(itemInfo, htmDir, "htm"); 
        saveBuildSummary(itemInfo, fileSummary);
    }
    
    // delete the dll if it was copied
    if (copyDll && dllCopied)
    {
        try
        {
            fso.DeleteFile(exeFolder.Path + "\\" + dllName);
        }
        catch(e)  // do nothing
        {
            fileLog.WriteLine("error: could not delete temporary file" + 
                exeFolder.Path + "\\" + dllName);
        }
    }

    // delete the rwtest.dll if it was copied
    if (copyRwtestDll && rwtdllCopied)
    {
        try
        {
            fso.DeleteFile(exeFolder.Path + "\\" + rwtdllName);
        }
        catch(e)  // do nothing
        {
            fileLog.WriteLine("error: could not delete temporary file" + 
                exeFolder.Path + "\\" + rwtdllName);
        }
    }
}

// run command without comparing the command output with expected output
// cmd - full path to the running executable
// exeFileName - filename of the running executable
// itemInfo - ItemBuildInfo object to hold the information
// fileLog - log filename
function runNoChecks(cmd, exeFileName, itemInfo, fileLog)
{
    var runCmd = utlExec + " -t " + runTimeout + " \"" + cmd + " < NUL:\"";
    
    var oExec = WshShell.Exec(runCmd);
    if (!oExec)
    {
        WScript.Echo(itemInfo.name + " failed to run");
        return;
    }

    while (oExec.Status == 0)
        WScript.Sleep(500);

    itemInfo.exitCode = oExec.ExitCode;
        
    itemInfo.runDiff = "";
    itemInfo.runOutput = "";
    
    var outFileName = cmd.replace(".exe", ".out");

    try
    {   
        var outFile = fso.OpenTextFile(outFileName, 1);
        
        var exeOutput = "";
        if (!outFile.AtEndOfStream)
          exeOutput = outFile.ReadAll();
            
        itemInfo.runOutput = exeOutput;
        
        outFile.Close();
        fso.DeleteFile(outFileName);
    }
    catch(e)
    {
        WScript.Echo("Could not delete temporary file " + outFileName);
    }

    var Status = oExec.StdOut.ReadAll();
    WScript.Echo(Status);

    if (itemInfo.exitCode == 0)
        itemInfo.exitCode = parseStatus(exeFileName, Status);

    if (itemInfo.exitCode != 0)
        exBadCode++;
  
    exRunSucceeded++;
  
    WScript.Echo("example succeeded! Exit code " + itemInfo.exitCode);
    fileLog.WriteLine(itemInfo.name + " completed successfully, exit code "
        + itemInfo.exitCode);
   
    WScript.Echo("   ");
    fileLog.WriteLine(" ");
}

// parse the exec utility output to get status of the running executable 
// exename - filename of the executable
// exeOut - stdout content of the exec utility
function parseStatus(exeName, execOut)
{
    var res = 0;

    var pos = execOut.indexOf(exeName);
    if (0 <= pos)
    {
        var status = execOut.substr(pos + 26, 6);
        res = parseInt(status);
        if (isNaN(res))
        {
            switch (status)
            {
            case "KILLED":
                ++exRunTimedOut;
                break;
            }
            res = 0;
        }
    }

    return res;
}

// run command and compare the command output with expected output
// cmd - full path to the running executable
// exeFileName - filename of the running executable
// itemInfo - ItemBuildInfo object to hold the information
// outData - the expected output of the command
// fileLog - log filename
function runWithChecks(cmd, exeFileName, itemInfo, outData, fileLog)
{
    var runCmd = utlExec + " -t " + runTimeout + " -d " + inoutDir +
                 " \"" + cmd + "\"";

    var oExec = WshShell.Exec(runCmd);
    if (!oExec)
    {
        WScript.Echo(itemInfo.name + " failed to run");
        return;
    }
            
    while (oExec.Status == 0)
        WScript.Sleep(500);

    var outFileName = cmd.replace(".exe", ".out");

    try
    {   
        var outFile = fso.OpenTextFile(outFileName, 1);
        
        var exeOutput = "";
        if (!outFile.AtEndOfStream)
          exeOutput = outFile.ReadAll();
            
        itemInfo.runOutput = exeOutput;
        
        outFile.Close();
        fso.DeleteFile(outFileName);
    }
    catch(e)
    {
        WScript.Echo("Could not delete temporary file " + outFileName);
    }

    var Status = oExec.StdOut.ReadAll();
    WScript.Echo(Status);

    itemInfo.runOutput = exeOutput;
    itemInfo.exitCode = oExec.ExitCode;
    itemInfo.runReqOutput = outData;
  
    if (itemInfo.exitCode == 0)
        itemInfo.exitCode = parseStatus(exeFileName, Status);

    if (itemInfo.exitCode != 0)
        exBadCode++;

    if (exeOutput == outData)
    {
        itemInfo.runDiff = "";
    
        exRunSucceeded++;
        WScript.Echo("example succeeded! Exit code " + oExec.ExitCode);
        fileLog.WriteLine(itemInfo.name + 
            " completed successfully, exit code " +
            itemInfo.exitCode);
    }
    else
    {
        WScript.Echo("example output differs from the expected");
        getDifferencesInfo(itemInfo);
    
        exRunFailed++;
        WScript.Echo("example failed! Exit code " + oExec.ExitCode);
        fileLog.WriteLine(itemInfo.name + 
            " completed with errors, exit code " +
            itemInfo.exitCode);
    }
    
    WScript.Echo("   ");
    fileLog.WriteLine(" ");
}

// returns the content of the .in or .out file for the specified executable
// srcDir - folder containing subfolders with .in and .out files
// exeFileName - filename of the executable
// nameSuffix - one of varIn, varOut
function readAllFromFile(srcDir, exeFileName, nameSuffix)
{   
    if (! fso.FolderExists(srcDir))
        return "";
        
    var pureName = getPureFileName(exeFileName, "exe");
        
    var someDir = srcDir + "\\" + nameSuffix;
    if (! fso.FolderExists(someDir))
        return "";
        
    var someFileName = someDir + "\\" + pureName + "." + nameSuffix;
    if (! fso.FileExists(someFileName))
        return "";
        
    var someFile = fso.OpenTextFile(someFileName);
    if (! someFile)
        return "";
        
    return (someFile.ReadAll());
}

// returns the content of the .in file for the specified executable
// srcDir - folder containing .in files
// exeFileName - filename of the executable
function readInFile(srcDir, exeFileName)
{
    return readAllFromFile(srcDir, exeFileName, varIn);
}

// returns the content of the .out file for the specified executable
// srcDir - folder containing .out files
// exeFileName - filename of the executable
function readOutFile(srcDir, exeFileName)
{
    var outData = readAllFromFile(srcDir, exeFileName, varOut);
    
    var eolStr = String.fromCharCode(13) + String.fromCharCode(10);
    var idxEOL = outData.indexOf(eolStr);
    var outBegin = (idxEOL != -1) ? outData.substr(0, idxEOL) : outData;
    var rgWords = outBegin.split(" ");
    if (rgWords[0] != "link")
        return outData;
    
    // try to open file using the link
    var linkedFileName = srcDir + "\\" + varOut + "\\" + rgWords[1];
    if (! fso.FileExists(linkedFileName))
        return outData;
            
    var linkedFile = fso.OpenTextFile(linkedFileName);
    if (! linkedFile)
        return "";
            
    return (linkedFile.ReadAll());
}

// returns the filename without extension
// fileName - source filename
// fileExtension - extension of the file
function getPureFileName(fileName, fileExtension)
{   
    var pureName = fileName;
    var indexTmp = fileName.lastIndexOf("." + fileExtension);
    if (indexTmp != -1)
        pureName = fileName.substr(0, indexTmp);
        
    return pureName;
}


]]>
        </script>
    </job>
</package>
